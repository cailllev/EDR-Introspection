// EPIC (Extensible Position Independent Code)
//
// Source: github.com/Print3M/epic
// Author: Print3M
//
// This is an example module generated by EPIC.
//
#include <core/pebwalker.h>
#include <win32/windows.h>
#include <libc/wchar.h>

// definitions
#define SW_SHOWNORMAL 0x1

// general
typedef HMODULE (WINAPI* LoadLibraryAPtr)(
    LPCSTR lpLibFileName
    );

// proc functions
typedef HANDLE(*OpenProcessPtr)(
    DWORD dwDesiredAccess,
    BOOL  bInheritHandle,
    DWORD dwProcessId
    );
typedef NTSTATUS(*NtQuerySystemInformationPtr)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID                    SystemInformation,
    ULONG                    SystemInformationLength,
    PULONG                   ReturnLength
    );
typedef LPVOID(*VirtualAllocPtr)(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flAllocationType,
    DWORD  flProtect
    );
typedef LPVOID(*VirtualProtectPtr)(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flNewProtect,
    PDWORD  lpflOldProtect
    );
typedef NTSTATUS(*NtQueryInformationProcessPtr)(
    HANDLE           ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID            ProcessInformation,
    ULONG            ProcessInformationLength,
    PULONG           ReturnLength
    );
typedef NTSTATUS(*NtReadVirtualMemoryPtr)(
    HANDLE  ProcessHandle,
    PVOID   BaseAddress,
    PVOID   Buffer,
    SIZE_T  NumberOfBytesToRead,
    PSIZE_T NumberOfBytesRead
    );

// minidump
typedef HANDLE (WINAPI* CreateFileAPtr)(
    LPCSTR                lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    );
typedef BOOL(WINAPI* MiniDumpWriteDumpPtr)(
    HANDLE        hProcess,
    DWORD         ProcessId,
    HANDLE        hFile,
    MINIDUMP_TYPE DumpType,
    PVOID         ExceptionParam,
    PVOID         UserStreamParam,
    PVOID         CallbackParam
    );

// message functions
typedef INT (*MessageBoxAPtr)(
    HWND   hWnd, 
    LPCSTR lpText, 
    LPCSTR lpCaption, 
    UINT   uType
    );

namespace utils {

    void message(const char* msg, const char* title) {
        auto kernel32 = GetDllFromMemory(L"kernel32.dll");
        auto LoadLibraryA = (LoadLibraryAPtr)GetProcAddr(kernel32, "LoadLibraryA");
        auto user32 = LoadLibraryA("user32.dll");
        if (user32) {
            auto MessageBoxA = (MessageBoxAPtr)GetProcAddr(user32, "MessageBoxA");
            if (MessageBoxA) {
                MessageBoxA(NULL, msg, title, 0);
            }
        }
    }

    void message_hex(void* p, const char* title) {
        char out[19];
        const char HEX[] = "0123456789ABCDEF";
        unsigned long long v = (unsigned long long)p;
        out[0] = '0';
        out[1] = 'x';
        for (int i = 0; i < 16; i++) {
            out[17 - i] = HEX[v & 0xF];
            v >>= 4;
        }
        out[18] = 0;
        message(out, title);
    }

    void message_encode(const char* msg, int len, const char* title) {
        char out[len * 2 + 1];       // 2 hex chars per byte + NULL
        const char HEX[] = "0123456789ABCDEF";
        for (int i = 0; i < len; i++) {
            unsigned char b = (unsigned char)msg[i];
            out[i * 2] = HEX[b >> 4];
            out[i * 2 + 1] = HEX[b & 0x0F];
        }
        out[len * 2] = 0; // null terminate
        message(out, title);
    }

    int64_t get_pid_by_name(const wchar_t* targetName) {

        auto ntdll = GetDllFromMemory(L"ntdll.dll");
        if (!ntdll) return -1;

        auto kernel32 = GetDllFromMemory(L"kernel32.dll");
        if (!kernel32) return -1;

        NtQuerySystemInformationPtr NtQuerySystemInformation = (NtQuerySystemInformationPtr)GetProcAddr(ntdll, "ZwQuerySystemInformation");
        if (!NtQuerySystemInformation) return -1;

        VirtualAllocPtr VirtualAlloc = (VirtualAllocPtr)GetProcAddr(kernel32, "VirtualAlloc");
        if (!VirtualAlloc) return -1;

        // first call to get size (else STATUS_INFO_LENGTH_MISMATCH)
        ULONG outSize = 0;
        NTSTATUS st = NtQuerySystemInformation(SystemProcessInformation, NULL, 0, &outSize);
        if (st != STATUS_INFO_LENGTH_MISMATCH) return -1;

        uint8_t* buffer = (uint8_t*)VirtualAlloc(NULL, outSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        st = NtQuerySystemInformation(SystemProcessInformation, buffer, outSize, &outSize);
        if (st != STATUS_SUCCESS) return -1;

        SYSTEM_PROCESS_INFORMATION* spi = (SYSTEM_PROCESS_INFORMATION*)buffer;
        while (true) { // Iterate through SYSTEM_PROCESS_INFORMATION entries
            if (spi->ImageName.Buffer && spi->ImageName.Length > 0 && wcsicmp(spi->ImageName.Buffer, targetName) == 0) {
                return (int64_t)spi->UniqueProcessId;
            }
            if (spi->NextEntryOffset == 0)
                break;
            spi = (SYSTEM_PROCESS_INFORMATION*)((BYTE*)spi + spi->NextEntryOffset);
        }
        return -1;
    }

    HANDLE open_process_by_pid(int pid) {
        auto kernel32 = GetDllFromMemory(L"kernel32.dll");
        auto OpenProcess = (OpenProcessPtr)GetProcAddr(kernel32, "OpenProcess");
        HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
        return h;
    }

    bool ResolveDelayImports(HMODULE hModule, HMODULE hDep) {
        if (!hModule) return false;
        BYTE* base = (BYTE*)hModule;

        auto kernel32 = GetDllFromMemory(L"kernel32.dll");
        if (!kernel32) return false;

        LoadLibraryAPtr LoadLibraryA = (LoadLibraryAPtr)GetProcAddr(kernel32, "LoadLibraryA");
        if (!LoadLibraryA) return false;

        VirtualProtectPtr VirtualProtect = (VirtualProtectPtr)GetProcAddr(kernel32, "VirtualProtect");
        if (!VirtualProtect) return -1;

        // Parse headers
        IMAGE_DOS_HEADER* dos = (IMAGE_DOS_HEADER*)base;
        if (dos->e_magic != IMAGE_DOS_SIGNATURE) return false;

        IMAGE_NT_HEADERS64* nt = (IMAGE_NT_HEADERS64*)(base + dos->e_lfanew);
        if (nt->Signature != IMAGE_NT_SIGNATURE) return false;

        IMAGE_DATA_DIRECTORY delayDir = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];
        if (delayDir.VirtualAddress == 0 || delayDir.Size == 0) {
            // No delay imports
            return true;
        }

        PMY_IMAGE_DELAYLOAD_DESCRIPTOR desc = (PMY_IMAGE_DELAYLOAD_DESCRIPTOR)(base + delayDir.VirtualAddress);

        // Walk descriptors until an all-zero descriptor (DLLNameRVA == 0)
        for (; desc->DllNameRVA != 0; ++desc) {
            const char* dllName = (const char*)(base + desc->DllNameRVA);
            if (!dllName) continue;
            //message(dllName, "loading delayed");

            // Compute the IAT and INT addresses
            DWORD iatRva = desc->ImportAddressTableRVA;
            DWORD intRva = desc->ImportNameTableRVA;
            if (iatRva == 0 || intRva == 0) {
                // nothing to fix
                //message(dllName, "nothing to fix");
                continue;
            }

            ULONG_PTR* pIAT = (ULONG_PTR*)(base + iatRva);
            IMAGE_THUNK_DATA64* pINT = (IMAGE_THUNK_DATA64*)(base + intRva);

            // Iterate through entries until a zero pointer in IAT
            for (size_t idx = 0;; ++idx) {
                //message(dllName, "fixing...");

                // read IAT entry
                ULONG_PTR* iatEntryAddr = &pIAT[idx];
                ULONG_PTR iatVal = *iatEntryAddr;
                IMAGE_THUNK_DATA64 iData = pINT[idx];

                // Termination: when both INT and IAT entry are zero
                if (iData.u1.AddressOfData == 0 && iatVal == 0) break;

                // Determine if import by ordinal or by name
                bool byOrdinal = (iData.u1.Ordinal & IMAGE_ORDINAL_FLAG64) != 0;
                FARPROC target = NULL;
                if (byOrdinal) {
                    WORD ordinal = (WORD)(iData.u1.Ordinal & 0xFFFF);
                    target = (FARPROC)GetProcAddr(hDep, (LPCSTR)(uintptr_t)ordinal);
                    //message_hex(target, "fixing ord # ...");
                }
                else {
                    IMAGE_IMPORT_BY_NAME* ibn = (IMAGE_IMPORT_BY_NAME*)(base + (DWORD)iData.u1.AddressOfData);
                    const char* funcName = (const char*)ibn->Name;
                    target = GetProcAddr(hDep, funcName);
                    //message(funcName, "fixing ...");
                }

                if (!target) {
                    message_hex(iatEntryAddr, "target func not found");
                    return false;
                }

                // If the IAT already points correctly, skip
                if ((ULONG_PTR)iatVal == (ULONG_PTR)target) {
                    continue;
                }

                // Write the resolved pointer into the IAT slot
                DWORD old;
                VirtualProtect(iatEntryAddr, sizeof(ULONG_PTR), PAGE_READWRITE, &old);
                *iatEntryAddr = (ULONG_PTR)target;
                VirtualProtect(iatEntryAddr, sizeof(ULONG_PTR), old, &old);
            }
        }

        return true;
    }

    bool proc_mini_dump(HANDLE hProc, DWORD pid) {
        char outFile[] = "C:\\Users\\Public\\Downloads\\out.dmp";

        auto kernel32 = GetDllFromMemory(L"kernel32.dll");
        if (!kernel32) return false;

        LoadLibraryAPtr LoadLibraryA = (LoadLibraryAPtr)GetProcAddr(kernel32, "LoadLibraryA");
        if (!LoadLibraryA) return false;

        HMODULE hDep = LoadLibraryA("rpcrt4.dll"); // ensure rpcrt4 is available
        if (!hDep) {
            message("cannot load dependet rpcrt4.dll", "mini error");
            return false;
        }

        HMODULE hDbghelp = LoadLibraryA("dbghelp.dll");
        if (!hDbghelp) {
            message("cannot load dbghelp.dll", "mini error");
            return false;
        }

        LoadLibraryA("dbgcore.dll");

        if (!ResolveDelayImports(hDbghelp, hDep)) {
            message("failed to load delayed dlls", "mini error");
            return false;
        }

        message("resolved delayload dlls", "dbghelp.dll");

        CreateFileAPtr CreateFileA = (CreateFileAPtr)GetProcAddr(kernel32, "CreateFileA");
        if (!CreateFileA) return false;

        MiniDumpWriteDumpPtr MiniDumpWriteDump = (MiniDumpWriteDumpPtr)GetProcAddr(hDbghelp, "MiniDumpWriteDump");
        if (!MiniDumpWriteDump) return false;

        HANDLE hFile = CreateFileA(outFile, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            return false;
        }
        message("after create", "mini");
        BOOL ret = MiniDumpWriteDump(hProc, pid, hFile, MiniDumpWithFullMemory, NULL, NULL, NULL);
        message("after write", "mini");
        return ret == TRUE;
    }

}