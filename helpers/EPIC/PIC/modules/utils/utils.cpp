// EPIC (Extensible Position Independent Code)
//
// Source: github.com/Print3M/epic
// Author: Print3M
//
// This is an example module generated by EPIC.
//
#include <core/pebwalker.h>
#include <win32/windows.h>
#include <libc/wchar.h>

// definitions
#define SW_SHOWNORMAL 0x1

// proc functions
typedef HANDLE(*OpenProcessPtr)(
    DWORD dwDesiredAccess,
    BOOL  bInheritHandle,
    DWORD dwProcessId
    );
typedef NTSTATUS(*NtQuerySystemInformationPtr)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID                    SystemInformation,
    ULONG                    SystemInformationLength,
    PULONG                   ReturnLength
    );
typedef LPVOID(*VirtualAllocPtr)(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flAllocationType,
    DWORD  flProtect
    );
typedef NTSTATUS(*NtQueryInformationProcessPtr)(
    HANDLE           ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID            ProcessInformation,
    ULONG            ProcessInformationLength,
    PULONG           ReturnLength
    );
typedef NTSTATUS(*NtReadVirtualMemoryPtr)(
    HANDLE  ProcessHandle,
    PVOID   BaseAddress,
    PVOID   Buffer,
    SIZE_T  NumberOfBytesToRead,
    PSIZE_T NumberOfBytesRead
    );

// message functions
typedef HMODULE (*LoadLibraryAPtr)(
    LPCSTR lpLibFileName
    );
typedef INT (*MessageBoxAPtr)(
    HWND   hWnd, 
    LPCSTR lpText, 
    LPCSTR lpCaption, 
    UINT   uType
    );

namespace utils {

    void message(const char* msg, const char* title) {
        auto kernel32 = GetDllFromMemory(L"kernel32.dll");
        auto LoadLibraryA = (LoadLibraryAPtr)GetProcAddr(kernel32, "LoadLibraryA");
        auto user32 = LoadLibraryA("user32.dll");
        if (user32) {
            auto MessageBoxA = (MessageBoxAPtr)GetProcAddr(user32, "MessageBoxA");
            if (MessageBoxA) {
                MessageBoxA(NULL, msg, title, 0);
            }
        }
    }

    void message_hex(void* p, const char* title) {
        char out[19];
        const char HEX[] = "0123456789ABCDEF";
        unsigned long long v = (unsigned long long)p;
        out[0] = '0';
        out[1] = 'x';
        for (int i = 0; i < 16; i++) {
            out[17 - i] = HEX[v & 0xF];
            v >>= 4;
        }
        out[18] = 0;
        message(out, title);
    }

    void message_encode(const char* msg, int len, const char* title) {
        char out[len * 2 + 1];       // 2 hex chars per byte + NULL
        const char HEX[] = "0123456789ABCDEF";
        for (int i = 0; i < len; i++) {
            unsigned char b = (unsigned char)msg[i];
            out[i * 2] = HEX[b >> 4];
            out[i * 2 + 1] = HEX[b & 0x0F];
        }
        out[len * 2] = 0; // null terminate
        message(out, title);
    }

    void message_wchar(const wchar_t* msg, const char* title) {
        size_t len = 0;
        while (msg[len] != L'\0') {
            len++;
        }
        char out[len + 1];
        for (size_t i = 0; i < len; i++) {
            out[i] = (char)(msg[i]);
        }
        out[len] = '\0';
        message(out, title);
    }

    int64_t get_pid_by_name(const wchar_t* targetName) {

        auto ntdll = GetDllFromMemory(L"ntdll.dll");
        if (!ntdll) return -1;

        auto kernel32 = GetDllFromMemory(L"kernel32.dll");
        if (!kernel32) return -1;

        NtQuerySystemInformationPtr NtQuerySystemInformation = (NtQuerySystemInformationPtr)GetProcAddr(ntdll, "ZwQuerySystemInformation");
        if (!NtQuerySystemInformation) return -1;

        VirtualAllocPtr VirtualAlloc = (VirtualAllocPtr)GetProcAddr(kernel32, "VirtualAlloc");
        if (!VirtualAlloc) return -1;

        // first call to get size (else STATUS_INFO_LENGTH_MISMATCH)
        ULONG outSize = 0;
        NTSTATUS st = NtQuerySystemInformation(SystemProcessInformation, NULL, 0, &outSize);
        if (st != STATUS_INFO_LENGTH_MISMATCH) return -1;

        uint8_t* buffer = (uint8_t*)VirtualAlloc(NULL, outSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        st = NtQuerySystemInformation(SystemProcessInformation, buffer, outSize, &outSize);
        if (st != STATUS_SUCCESS) return -1;

        SYSTEM_PROCESS_INFORMATION* spi = (SYSTEM_PROCESS_INFORMATION*)buffer;
        while (true) { // Iterate through SYSTEM_PROCESS_INFORMATION entries
            if (spi->ImageName.Buffer && spi->ImageName.Length > 0 && wcsicmp(spi->ImageName.Buffer, targetName) == 0) {
                return (int64_t)spi->UniqueProcessId;
            }
            if (spi->NextEntryOffset == 0)
                break;
            spi = (SYSTEM_PROCESS_INFORMATION*)((BYTE*)spi + spi->NextEntryOffset);
        }
        return -1;
    }

    HANDLE open_process_by_pid(int pid) {
        auto kernel32 = GetDllFromMemory(L"kernel32.dll");
        auto OpenProcess = (OpenProcessPtr)GetProcAddr(kernel32, "OpenProcess");
        HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
        return h;
    }

    bool read_data_section(HANDLE h, LPVOID outBuffer, SIZE_T outBufferSize) {
        auto ntdll = GetDllFromMemory(L"ntdll.dll");
        if (!ntdll) return false;

        auto ZwQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddr(ntdll, "ZwQueryInformationProcess");
        if (!ZwQueryInformationProcess) return false;

        auto NtReadVirtualMemory = (NtReadVirtualMemoryPtr)GetProcAddr(ntdll, "NtReadVirtualMemory");
        if (!NtReadVirtualMemory) return false;

        PROCESS_BASIC_INFORMATION pbi = { 0 };
        ULONG outLen = 0;

        NTSTATUS st = ZwQueryInformationProcess(h, ProcessBasicInformation, &pbi, sizeof(pbi), &outLen);
        if (st != 0) return false;

        PVOID remotePEB = pbi.PebBaseAddress;

        PEB localPEB = { 0 };
        SIZE_T bytes = 0;

        if (NtReadVirtualMemory(h, remotePEB, &localPEB, sizeof(localPEB), &bytes) != 0)
            return false;

        PEB_LDR_DATA ldr = { 0 };
        if (NtReadVirtualMemory(h, localPEB.Ldr, &ldr, sizeof(ldr), &bytes) != 0)
            return false;

        PLIST_ENTRY remoteHeadAddr = (PLIST_ENTRY)((uintptr_t)localPEB.Ldr + offsetof(PEB_LDR_DATA, InMemoryOrderModuleList));
        PLIST_ENTRY currAddr = remoteHeadAddr;
        message_hex(currAddr, "start");

        do {
            LDR_DATA_TABLE_ENTRY_PARTIAL entry = { 0 };

            if (NtReadVirtualMemory(h, currAddr, &entry, sizeof(entry), &bytes) != 0) {
                message("failed", "ntread");
                return false;
            }

            // read BaseDllName
            WCHAR nameBuf[260] = { 0 };
            if (entry.BaseDllName.Buffer && entry.BaseDllName.Length < sizeof(nameBuf)) {
                st = NtReadVirtualMemory(h, entry.BaseDllName.Buffer, nameBuf, entry.BaseDllName.Length, &bytes);
                if (st != STATUS_SUCCESS) {
                    //message_hex((void*)st, "read mem");
                    continue;
                }
                message_wchar(nameBuf, "image name");

                // match the main module (first in list)
                if (entry.DllBase != NULL) {

                    BYTE hdrBuf[0x1000] = { 0 };
                    if (NtReadVirtualMemory(h, entry.DllBase, hdrBuf, sizeof(hdrBuf), &bytes) != 0)
                        return false;

                    auto dos = (IMAGE_DOS_HEADER*)hdrBuf;
                    auto nt = (IMAGE_NT_HEADERS*)((BYTE*)hdrBuf + dos->e_lfanew);

                    IMAGE_SECTION_HEADER* sec = IMAGE_FIRST_SECTION(nt);
                    for (int i = 0; i < nt->FileHeader.NumberOfSections; i++, sec++) {

                        bool is_data = true;
                        const char dataname[5] = { '.','d','a','t','a' };
                        for (int j = 0; j < 5; j++) {
                            if (sec->Name[j] != dataname[j]) {
                                is_data = false;
                                break;
                            }
                        }

                        if (is_data) {
                            // cut down to outBufferSize if too big
                            SIZE_T toRead = (outBufferSize <= sec->Misc.VirtualSize) ? outBufferSize : sec->Misc.VirtualSize;
                            PVOID remoteData = (BYTE*)entry.DllBase + sec->VirtualAddress;
                            if (NtReadVirtualMemory(h, remoteData, outBuffer, toRead, &bytes) == 0) {
                                return true;
                            }
                        }
                    }
                }
            }
            
            LIST_ENTRY listEntry = { 0 };
            if (NtReadVirtualMemory(h, (PVOID)currAddr, &listEntry, sizeof(listEntry), &bytes) != 0)
                return false;

            currAddr = listEntry.Flink;
        } while (currAddr != remoteHeadAddr);

        return false;
    }

    bool read_process_heap(HANDLE h, LPVOID outBuffer, SIZE_T outBufferSize) {
        auto ntdll = GetDllFromMemory(L"ntdll.dll");
        if (!ntdll) return false;

        auto ZwQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddr(ntdll, "ZwQueryInformationProcess");
        if (!ZwQueryInformationProcess) return false;

        auto NtReadVirtualMemory = (NtReadVirtualMemoryPtr)GetProcAddr(ntdll, "NtReadVirtualMemory");
        if (!NtReadVirtualMemory) return false;

        // Retrieve PEB of remote process
        PROCESS_BASIC_INFORMATION pbi = { 0 };
        ULONG outLen = 0;

        if (ZwQueryInformationProcess(h, ProcessBasicInformation, &pbi, sizeof(pbi), &outLen) != STATUS_SUCCESS) {
            return false;
        }

        // Read remote PEB structure
        PEB remotePEB = { 0 };
        SIZE_T bytes = 0;

        if (NtReadVirtualMemory(h, pbi.PebBaseAddress, &remotePEB, sizeof(remotePEB), &bytes) != STATUS_SUCCESS) {
            return false;
        }

        // Remote process default heap
        PVOID remoteHeap = remotePEB.ProcessHeap;
        if (!remoteHeap) return false;

        // Read the beginning of the heap
        SIZE_T toRead = outBufferSize;

        NTSTATUS st = NtReadVirtualMemory(h, remoteHeap, outBuffer, toRead,&bytes);
        if (st == STATUS_SUCCESS) {
            return true;
        }
        return false;
    }

}