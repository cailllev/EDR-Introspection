// EPIC (Extensible Position Independent Code)
//
// Source: github.com/Print3M/epic
// Author: Print3M
//
// This is an example module generated by EPIC.
//
#include <core/pebwalker.h>
#include <win32/windows.h>
#include <libc/wchar.h>

// definitions
#define SW_SHOWNORMAL 0x1

// general
typedef HMODULE(WINAPI* LoadLibraryAPtr)(
    LPCSTR lpLibFileName
    );

// proc functions
typedef HANDLE(*OpenProcessPtr)(
    DWORD dwDesiredAccess,
    BOOL  bInheritHandle,
    DWORD dwProcessId
    );
typedef NTSTATUS(*NtQuerySystemInformationPtr)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID                    SystemInformation,
    ULONG                    SystemInformationLength,
    PULONG                   ReturnLength
    );
typedef LPVOID(*VirtualAllocPtr)(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flAllocationType,
    DWORD  flProtect
    );
typedef NTSTATUS(*NtQueryInformationProcessPtr)(
    HANDLE           ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID            ProcessInformation,
    ULONG            ProcessInformationLength,
    PULONG           ReturnLength
    );
typedef NTSTATUS(*NtReadVirtualMemoryPtr)(
    HANDLE  ProcessHandle,
    PVOID   BaseAddress,
    PVOID   Buffer,
    SIZE_T  NumberOfBytesToRead,
    PSIZE_T NumberOfBytesRead
    );

// minidump
typedef HANDLE(*CreateFileAPtr)(
    LPCSTR                lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    );
typedef BOOL(WINAPI *MiniDumpWriteDumpPtr)(
    HANDLE        hProcess,
    DWORD         ProcessId,
    HANDLE        hFile,
    MINIDUMP_TYPE DumpType,
    PVOID         ExceptionParam,
    PVOID         UserStreamParam,
    PVOID         CallbackParam
    );

// message functions
typedef INT (*MessageBoxAPtr)(
    HWND   hWnd, 
    LPCSTR lpText, 
    LPCSTR lpCaption, 
    UINT   uType
    );

namespace utils {

    void message(const char* msg, const char* title) {
        auto kernel32 = GetDllFromMemory(L"kernel32.dll");
        auto LoadLibraryA = (LoadLibraryAPtr)GetProcAddr(kernel32, "LoadLibraryA");
        auto user32 = LoadLibraryA("user32.dll");
        if (user32) {
            auto MessageBoxA = (MessageBoxAPtr)GetProcAddr(user32, "MessageBoxA");
            if (MessageBoxA) {
                MessageBoxA(NULL, msg, title, 0);
            }
        }
    }

    void message_hex(void* p, const char* title) {
        char out[19];
        const char HEX[] = "0123456789ABCDEF";
        unsigned long long v = (unsigned long long)p;
        out[0] = '0';
        out[1] = 'x';
        for (int i = 0; i < 16; i++) {
            out[17 - i] = HEX[v & 0xF];
            v >>= 4;
        }
        out[18] = 0;
        message(out, title);
    }

    void message_encode(const char* msg, int len, const char* title) {
        char out[len * 2 + 1];       // 2 hex chars per byte + NULL
        const char HEX[] = "0123456789ABCDEF";
        for (int i = 0; i < len; i++) {
            unsigned char b = (unsigned char)msg[i];
            out[i * 2] = HEX[b >> 4];
            out[i * 2 + 1] = HEX[b & 0x0F];
        }
        out[len * 2] = 0; // null terminate
        message(out, title);
    }

    int64_t get_pid_by_name(const wchar_t* targetName) {

        auto ntdll = GetDllFromMemory(L"ntdll.dll");
        if (!ntdll) return -1;

        auto kernel32 = GetDllFromMemory(L"kernel32.dll");
        if (!kernel32) return -1;

        NtQuerySystemInformationPtr NtQuerySystemInformation = (NtQuerySystemInformationPtr)GetProcAddr(ntdll, "ZwQuerySystemInformation");
        if (!NtQuerySystemInformation) return -1;

        VirtualAllocPtr VirtualAlloc = (VirtualAllocPtr)GetProcAddr(kernel32, "VirtualAlloc");
        if (!VirtualAlloc) return -1;

        // first call to get size (else STATUS_INFO_LENGTH_MISMATCH)
        ULONG outSize = 0;
        NTSTATUS st = NtQuerySystemInformation(SystemProcessInformation, NULL, 0, &outSize);
        if (st != STATUS_INFO_LENGTH_MISMATCH) return -1;

        uint8_t* buffer = (uint8_t*)VirtualAlloc(NULL, outSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        st = NtQuerySystemInformation(SystemProcessInformation, buffer, outSize, &outSize);
        if (st != STATUS_SUCCESS) return -1;

        SYSTEM_PROCESS_INFORMATION* spi = (SYSTEM_PROCESS_INFORMATION*)buffer;
        while (true) { // Iterate through SYSTEM_PROCESS_INFORMATION entries
            if (spi->ImageName.Buffer && spi->ImageName.Length > 0 && wcsicmp(spi->ImageName.Buffer, targetName) == 0) {
                return (int64_t)spi->UniqueProcessId;
            }
            if (spi->NextEntryOffset == 0)
                break;
            spi = (SYSTEM_PROCESS_INFORMATION*)((BYTE*)spi + spi->NextEntryOffset);
        }
        return -1;
    }

    HANDLE open_process_by_pid(int pid) {
        auto kernel32 = GetDllFromMemory(L"kernel32.dll");
        auto OpenProcess = (OpenProcessPtr)GetProcAddr(kernel32, "OpenProcess");
        HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
        return h;
    }

    bool proc_mini_dump(HANDLE hProc, DWORD pid) {
        char outFile[] = "C:\\Users\\Public\\Downloads\\out.dmp";

        auto kernel32 = GetDllFromMemory(L"kernel32.dll");
        if (!kernel32) return false;

        LoadLibraryAPtr LoadLibraryA = (LoadLibraryAPtr)GetProcAddr(kernel32, "LoadLibraryA");
        if (!LoadLibraryA) return false;

        HMODULE hModule = LoadLibraryA("dbghelp.dll");
        if (hModule == NULL) return false;

        HMODULE h1 = LoadLibraryA("dbgcore.dll"); // dbghelp depends on this
        if (!h1) return false;

        HMODULE h2 = LoadLibraryA("rpcrt4.dll"); // dbghelp depends on this
        if (!h2) return false;

        CreateFileAPtr CreateFileA = (CreateFileAPtr)GetProcAddr(kernel32, "CreateFileA");
        if (!CreateFileA) return false;

        MiniDumpWriteDumpPtr MiniDumpWriteDump = (MiniDumpWriteDumpPtr)GetProcAddr(hModule, "MiniDumpWriteDump");
        if (!MiniDumpWriteDump) return false;

        HANDLE hFile = CreateFileA(outFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            return false;
        }
        message("after create", "mini");
        BOOL ret = MiniDumpWriteDump(hProc, pid, hFile, MiniDumpWithFullMemory, NULL, NULL, NULL);
        message("after write", "mini");
        return ret == TRUE;
    }

}