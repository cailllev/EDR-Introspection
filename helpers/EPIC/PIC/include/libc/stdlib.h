// EPIC (Extensible Position Independent Code)
//
// Source: github.com/Print3M/epic
// Author: Print3M
//
// Minimal stddef.h for shellcoding (PIC-compatible)
// Generated by LLM: Claude 4.5 (reasoning)

#pragma once

#include "ctype.h"
#include "limits.h"
#include "stddef.h"
#include "stdint.h"
#include "string.h"

/* Standard result structs */
typedef struct {
	int quot;
	int rem;
} div_t;

typedef struct {
	long quot;
	long rem;
} ldiv_t;

static inline int abs(int x) {
	return (x < 0) ? -x : x;
}

static inline long labs(long x) {
	return (x < 0) ? -x : x;
}

static inline div_t div(int num, int denom) {
	div_t r;
	r.quot = num / denom;
	r.rem  = num % denom;
	return r;
}

static inline ldiv_t ldiv(long num, long denom) {
	ldiv_t r;
	r.quot = num / denom;
	r.rem  = num % denom;
	return r;
}

static inline int atoi(const char *s) {
	while (*s && (*s == ' ' || *s == '\t' || *s == '\n' || *s == '\r' || *s == '\f' || *s == '\v')
	) {
		s++;
	}
	int neg = 0;
	if (*s == '+' || *s == '-') {
		neg = (*s == '-');
		s++;
	}
	int v = 0;
	while (*s >= '0' && *s <= '9') {
		v = v * 10 + (*s - '0');
		s++;
	}
	return neg ? -v : v;
}

static inline double atof(const char *s) {
	while (*s && (*s == ' ' || *s == '\t' || *s == '\n' || *s == '\r' || *s == '\f' || *s == '\v')
	) {
		s++;
	}
	int neg = 0;
	if (*s == '+' || *s == '-') {
		neg = (*s == '-');
		s++;
	}

	double ip = 0.0;
	while (*s >= '0' && *s <= '9') {
		ip = ip * 10.0 + (double) (*s - '0');
		s++;
	}

	double fp	 = 0.0;
	double scale = 1.0;
	if (*s == '.') {
		s++;
		while (*s >= '0' && *s <= '9') {
			fp = fp * 10.0 + (double) (*s - '0');
			scale *= 10.0;
			s++;
		}
	}

	int exp10 = 0;
	if (*s == 'e' || *s == 'E') {
		s++;
		int eneg = 0;
		if (*s == '+' || *s == '-') {
			eneg = (*s == '-');
			s++;
		}
		while (*s >= '0' && *s <= '9') {
			exp10 = exp10 * 10 + (*s - '0');
			s++;
		}
		if (eneg)
			exp10 = -exp10;
	}

	/* fast pow10 by squaring */
	double pow10 = 1.0;
	double base	 = (exp10 < 0) ? 0.1 : 10.0;
	int e		 = (exp10 < 0) ? -exp10 : exp10;
	while (e) {
		if (e & 1)
			pow10 *= base;
		base *= base;
		e >>= 1;
	}

	double v = (ip + (scale > 1.0 ? fp / scale : 0.0)) * pow10;
	return neg ? -v : v;
}

static inline char *itoa(int value, char *str, int base) {
	if (base < 2 || base > 36) {
		str[0] = '\0';
		return str;
	}
	unsigned int u;
	int neg = 0;
	if (base == 10 && value < 0) {
		neg = 1;
		u	= (unsigned int) (-(long long) value);
	} else {
		u = (unsigned int) value;
	}
	char *p = str;
	do {
		unsigned int d = u % (unsigned) base;
		*p++		   = (char) ("0123456789abcdefghijklmnopqrstuvwxyz"[d]);
		u /= (unsigned) base;
	} while (u);
	if (neg)
		*p++ = '-';
	*p = '\0';

	/* reverse */
	char *a = str, *b = p - 1;
	while (a < b) {
		char t = *a;
		*a++   = *b;
		*b--   = t;
	}
	return str;
}

/* ============================================================================
 * Shellcode-specific utility functions
 * ============================================================================ */

/* Convert long to string (base 10) */
static inline char *ltoa(long value, char *str, int base) {
    /* Validate base */
    if (base < 2 || base > 36) {
        *str = '\0';
        return str;
    }
    
    char *ptr = str;
    char *ptr1 = str;
    char tmp_char;
    long tmp_value;
    
    /* Handle negative numbers for base 10 */
    int is_negative = 0;
    if (value < 0 && base == 10) {
        is_negative = 1;
        value = -value;
    }
    
    /* Convert to unsigned */
    unsigned long uvalue = (unsigned long)value;
    
    /* Convert number to string (reversed) */
    do {
        tmp_value = uvalue % base;
        *ptr++ = (tmp_value < 10) ? (tmp_value + '0') : (tmp_value - 10 + 'a');
        uvalue /= base;
    } while (uvalue);
    
    /* Add negative sign for base 10 */
    if (is_negative) {
        *ptr++ = '-';
    }
    
    /* Null terminate */
    *ptr-- = '\0';
    
    /* Reverse the string */
    while (ptr1 < ptr) {
        tmp_char = *ptr;
        *ptr-- = *ptr1;
        *ptr1++ = tmp_char;
    }
    
    return str;
}

/* Convert unsigned integer to string */
static inline char *utoa(unsigned int value, char *str, int base) {
    /* Validate base */
    if (base < 2 || base > 36) {
        *str = '\0';
        return str;
    }
    
    char *ptr = str;
    char *ptr1 = str;
    char tmp_char;
    unsigned int tmp_value;
    
    /* Convert number to string (reversed) */
    do {
        tmp_value = value % base;
        *ptr++ = (tmp_value < 10) ? (tmp_value + '0') : (tmp_value - 10 + 'a');
        value /= base;
    } while (value);
    
    /* Null terminate */
    *ptr-- = '\0';
    
    /* Reverse the string */
    while (ptr1 < ptr) {
        tmp_char = *ptr;
        *ptr-- = *ptr1;
        *ptr1++ = tmp_char;
    }
    
    return str;
}

/* Convert pointer to address string */
static inline char *ptrtoa(void *ptr, char *buffer) {
    uintptr_t addr = (uintptr_t)ptr;
    char *p = buffer;
    
    *p++ = '0';
    *p++ = 'x';
    
    // Convert to hex (16 digits for 64-bit)
    for (int i = 60; i >= 0; i -= 4) {
        int digit = (addr >> i) & 0xF;
        *p++ = (digit < 10) ? ('0' + digit) : ('a' + digit - 10);
    }
    *p = '\0';
    
    return buffer;
}