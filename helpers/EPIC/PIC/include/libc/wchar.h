// EPIC (Extensible Position Independent Code)
//
// Source: github.com/Print3M/epic
// Author: Print3M
//
// Minimal wchar.h for shellcoding (PIC-compatible)
// Generated by LLM: Claude 4.5 (reasoning)

#pragma once

#include "stddef.h"
#include "stdint.h"

/* Wide character string terminator */
#define WEOF ((wchar_t)-1)

#ifndef _WINT_T_DEFINED
#define _WINT_T_DEFINED
typedef unsigned int wint_t;
#endif

/* ============================================================================
 * Wide character memory manipulation functions
 * ============================================================================ */

static inline wchar_t *wmemcpy(wchar_t *dest, const wchar_t *src, size_t n) {
    wchar_t *d = dest;
    while (n--) {
        *d++ = *src++;
    }
    return dest;
}

static inline wchar_t *wmemset(wchar_t *dest, wchar_t c, size_t n) {
    wchar_t *d = dest;
    while (n--) {
        *d++ = c;
    }
    return dest;
}

static inline wchar_t *wmemmove(wchar_t *dest, const wchar_t *src, size_t n) {
    wchar_t *d = dest;
    const wchar_t *s = src;
    
    if (d < s) {
        /* Copy forward */
        while (n--) {
            *d++ = *s++;
        }
    } else if (d > s) {
        /* Copy backward to handle overlap */
        d += n;
        s += n;
        while (n--) {
            *(--d) = *(--s);
        }
    }
    return dest;
}

static inline int wmemcmp(const wchar_t *s1, const wchar_t *s2, size_t n) {
    while (n--) {
        if (*s1 != *s2) {
            return *s1 - *s2;
        }
        s1++;
        s2++;
    }
    return 0;
}

static inline wchar_t *wmemchr(const wchar_t *s, wchar_t c, size_t n) {
    while (n--) {
        if (*s == c) {
            return (wchar_t *)s;
        }
        s++;
    }
    return NULL;
}

/* ============================================================================
 * Wide string examination functions
 * ============================================================================ */

static inline size_t wcslen(const wchar_t *s) {
    const wchar_t *p = s;
    while (*p) {
        p++;
    }
    return (size_t)(p - s);
}

static inline int wcscmp(const wchar_t *s1, const wchar_t *s2) {
    while (*s1 && (*s1 == *s2)) {
        s1++;
        s2++;
    }
    return *s1 - *s2;
}

static inline int wcsncmp(const wchar_t *s1, const wchar_t *s2, size_t n) {
    while (n && *s1 && (*s1 == *s2)) {
        s1++;
        s2++;
        n--;
    }
    if (n == 0) {
        return 0;
    }
    return *s1 - *s2;
}

/* ============================================================================
 * Wide string manipulation functions
 * ============================================================================ */

static inline wchar_t *wcscpy(wchar_t *dest, const wchar_t *src) {
    wchar_t *d = dest;
    while ((*d++ = *src++));
    return dest;
}

static inline wchar_t *wcsncpy(wchar_t *dest, const wchar_t *src, size_t n) {
    wchar_t *d = dest;
    while (n && (*d++ = *src++)) {
        n--;
    }
    /* Pad with zeros if src is shorter than n */
    while (n--) {
        *d++ = L'\0';
    }
    return dest;
}

static inline wchar_t *wcscat(wchar_t *dest, const wchar_t *src) {
    wchar_t *d = dest;
    /* Find end of dest */
    while (*d) {
        d++;
    }
    /* Copy src to end */
    while ((*d++ = *src++));
    return dest;
}

static inline wchar_t *wcsncat(wchar_t *dest, const wchar_t *src, size_t n) {
    wchar_t *d = dest;
    /* Find end of dest */
    while (*d) {
        d++;
    }
    /* Copy up to n characters from src */
    while (n && (*d++ = *src++)) {
        n--;
    }
    /* Ensure null termination */
    if (n == 0) {
        *d = L'\0';
    }
    return dest;
}

/* ============================================================================
 * Wide string search functions
 * ============================================================================ */

static inline wchar_t *wcschr(const wchar_t *s, wchar_t c) {
    while (*s != c) {
        if (!*s) {
            return NULL;
        }
        s++;
    }
    return (wchar_t *)s;
}

static inline wchar_t *wcsrchr(const wchar_t *s, wchar_t c) {
    const wchar_t *last = NULL;
    while (*s) {
        if (*s == c) {
            last = s;
        }
        s++;
    }
    /* Check if c is L'\0' */
    if (c == L'\0') {
        return (wchar_t *)s;
    }
    return (wchar_t *)last;
}

static inline wchar_t *wcsstr(const wchar_t *haystack, const wchar_t *needle) {
    if (!*needle) {
        return (wchar_t *)haystack;
    }
    
    while (*haystack) {
        const wchar_t *h = haystack;
        const wchar_t *n = needle;
        
        while (*h && *n && (*h == *n)) {
            h++;
            n++;
        }
        
        if (!*n) {
            return (wchar_t *)haystack;
        }
        
        haystack++;
    }
    return NULL;
}

/* ============================================================================
 * Shellcode-specific utility functions
 * ============================================================================ */

/* Case-insensitive wide string comparison (crucial for Windows API resolution) */
static inline int wcsicmp(const wchar_t *s1, const wchar_t *s2) {
    while (*s1 && *s2) {
        wchar_t c1 = *s1;
        wchar_t c2 = *s2;
        
        /* Convert to lowercase (ASCII range) */
        if (c1 >= L'A' && c1 <= L'Z') c1 += 32;
        if (c2 >= L'A' && c2 <= L'Z') c2 += 32;
        
        if (c1 != c2) {
            return c1 - c2;
        }
        
        s1++;
        s2++;
    }
    return *s1 - *s2;
}

/* Case-insensitive wide string comparison with length limit */
static inline int wcsnicmp(const wchar_t *s1, const wchar_t *s2, size_t n) {
    while (n && *s1 && *s2) {
        wchar_t c1 = *s1;
        wchar_t c2 = *s2;
        
        /* Convert to lowercase (ASCII range) */
        if (c1 >= L'A' && c1 <= L'Z') c1 += 32;
        if (c2 >= L'A' && c2 <= L'Z') c2 += 32;
        
        if (c1 != c2) {
            return c1 - c2;
        }
        
        s1++;
        s2++;
        n--;
    }
    
    if (n == 0) {
        return 0;
    }
    return *s1 - *s2;
}

/* Convert narrow string to wide string (ASCII only) */
static inline wchar_t *mbstowcs_simple(wchar_t *dest, const char *src, size_t n) {
    wchar_t *d = dest;
    while (n-- && *src) {
        *d++ = (wchar_t)(uint8_t)*src++;
    }
    if (n > 0) {
        *d = L'\0';
    }
    return dest;
}

/* Convert wide string to narrow string (ASCII only) */
static inline char *wcstombs_simple(char *dest, const wchar_t *src, size_t n) {
    char *d = dest;
    while (n-- && *src) {
        *d++ = (char)*src++;
    }
    if (n > 0) {
        *d = '\0';
    }
    return dest;
}

/* Zero wide string memory (compiler won't optimize away) */
static inline wchar_t *wmemzero(wchar_t *dest, size_t n) {
    volatile wchar_t *d = (volatile wchar_t *)dest;
    while (n--) {
        *d++ = L'\0';
    }
    return dest;
}
