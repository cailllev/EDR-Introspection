#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <unordered_map>
#include <vector>
#include <set>
#include <map>
#include <regex>
#include "json.hpp"

/*
- creates krabs ETW traces for Antimalware, Kernel, etc.
- invokes the attack, and reads the output.csv generated by the attack.exe
- merges the output.csv events in between the captured events
- then transforms the captured events into a "filtered" csv, ready for Timeline Explorer
*/

using json = nlohmann::json;
struct Event {
    json header;
    json properties;
    json property_types;
};
struct AttackEvent {
    std::string timestamp;
    std::string event_id;
    std::string message;
};

std::string timestamp = "timestamp";
std::string event_id = "event_id";
std::string task_name = "task_name";


// translate device paths to drive letters
std::string translate_if_path(const std::string& s) {
    std::string to_replace = "\\Device\\HarddiskVolume4\\";
    std::string replacement = "C:\\";
    int idx = s.find(to_replace);
    if (idx != std::string::npos) {
        return s.substr(0, idx) + replacement + s.substr(idx + to_replace.length());
    }
    return s;
}

// todo quoting errors with Timeline Explorer
void print_value(Event ev, std::string key) {
    if (ev.properties[key].is_string()) {
        std::string s = ev.properties[key].get<std::string>();
        s = translate_if_path(s);
        std::cout << "\"" << s << "\"";
    }
    else {
        std::cout << ev.properties[key].dump();
    }
}


// output all events as a sparse CSV timeline with merged PPID and FilePath
void output_timeline_csv(const std::vector<Event>& events) {
    // keys to merge for PPID and FilePath
    static const std::vector<std::string> ppid_keys = {
        "Parent PID", "TPID", "Target PID"
    };
    static const std::vector<std::string> filepath_keys = {
        "File Name", "File Path", "Process Image Path", "Name", "Reason Image Path"
    };

    // start of CSV header
    // TODO: "name" not allowed?
    std::vector<std::string> all_keys = { "timestamp","event_id","task_name","PID",
        "PPID","Message","Command Line","FilePath","VName","Sig Seq","Sig Sha" };

    // collect all property keys except merged ones, set automatically rejects duplicates
    for (const auto& ev : events) {
        for (auto it = ev.properties.begin(); it != ev.properties.end(); ++it) {
            // skip merged keys
            if (std::find(ppid_keys.begin(), ppid_keys.end(), it.key()) != ppid_keys.end()) continue;
            if (std::find(filepath_keys.begin(), filepath_keys.end(), it.key()) != filepath_keys.end()) continue;

            // skip already inserted keys
            if (std::find(all_keys.begin(), all_keys.end(), it.key()) != all_keys.end()) continue;

            // insert if it does not exists yet
            all_keys.push_back(it.key());
        }
    }

    // print CSV header
    for (const auto& key : all_keys) {
        std::cout << key << ",";
    }
    std::cout << "\n";

    // print each event as a row
    for (const auto& ev : events) {
        // traverse keys in order of csv header, print "" if the current event does not have this key
        for (const auto& key : all_keys) {

            // check if this event has a value for this key
            if (ev.properties.contains(key)) {
                print_value(ev, key);
            }
            // else check if the key is a merged key
            else if (std::find(ppid_keys.begin(), ppid_keys.end(), key) != ppid_keys.end()) {
                print_value(ev, key);
            }
            else if (std::find(filepath_keys.begin(), filepath_keys.end(), key) != filepath_keys.end()) {
                print_value(ev, key);
            }

            // else print "" to skip it
            else {
                std::cout << "";
            }
            std::cout << ",";
        }
        std::cout << "\n";
    }
}

// https://stackoverflow.com/questions/14265581/parse-split-a-string-in-c-using-string-delimiter-standard-c#answer-46931770
std::vector<std::string> split(const std::string& s, char delim) {
    std::vector<std::string> result;
    std::stringstream ss(s);
    std::string item;

    while (getline(ss, item, delim)) {
        result.push_back(item);
    }

    return result;
}

// TODO: parse csv?
std::vector<Event> read_lines(std::string infile) {
    std::vector<Event> attack_events;
    json header;

    std::string line;
    std::ifstream input(infile);

    // read the csv header first
    std::getline(input, line);
    std::string csv_header = line;

    // parse the rest
    while (std::getline(input, line)) {
        std::vector<std::string> data = split(line, ',');
        header[timestamp] = data[0];
        header[event_id] = data[1];
        header[task_name] = data[2];
        attack_events.push_back(
            Event {
                header, {}, {} // attack_events do not have any properties (for now)
            }
        );
    }

    return attack_events;
}

std::vector<Event> merge_events(const std::vector<Event> events, const std::vector<Event> attack_events) {
    if (attack_events.size() != 0) {
        std::vector<Event> merged;
        // merge events from attack.csv
        int idx_event_to_merge = 0;
        Event attack_event_to_merge = attack_events[idx_event_to_merge];

        for (const auto& ev : events) {
            // iterate until we find an ETW event AFTER the attack event
            if (attack_event_to_merge.header[timestamp] < ev.properties[timestamp].get<std::string>()) {
                merged.push_back(attack_event_to_merge); // insert attack before this event
                idx_event_to_merge += 1;
                if (idx_event_to_merge == attack_events.size()) {
                    break; // all merged
                }
                attack_event_to_merge = attack_events[idx_event_to_merge];
            }
            merged.push_back(ev); // insert the event (after the attack event)
        }
        // merge any attack_events that happened after the last event
        for (int i = idx_event_to_merge; i < attack_events.size(); i++) {
            merged.push_back(attack_events[i]);
        }

        return merged;
    }
    return events;
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <attack-output.csv>\n";
        return 1;
    }

    std::vector<Event> events; // TODO: capture it
    std::vector<Event> attack_events = read_lines(argv[1]);
    events = merge_events(events, attack_events);
    output_timeline_csv(events);
}