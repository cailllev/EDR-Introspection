#include <iostream>
#include <fstream>
#include <map>
#include <regex>
#include <set>
#include <sstream>
#include <string>
#include <string.h>
#include <unordered_map>
#include <vector>
#include <windows.h>
#include <tlhelp32.h> // import after windows.h, else all breaks, that's crazy, yo
#include <wchar.h>

#include "cxxopts.hpp"
#include "json.hpp"
#include "etwreader.h"
#include "globals.h"

/*
- creates krabs ETW traces for Antimalware, Kernel, etc.
- invokes the attack, and reads the output.csv generated by the attack.exe
- merges the output.csv events in between the captured events
- then transforms the captured events into a "filtered" csv, ready for Timeline Explorer
*/

// PID of the EDR process, used to filter the ETW Antimalware provider
int g_EDR_PID = 0;


// translate device paths to drive letters
std::string translate_if_path(const std::string& s) {
    std::string to_replace = "\\Device\\HarddiskVolume4\\";
    std::string replacement = "C:\\";
    size_t idx = s.find(to_replace);
    if (idx != std::string::npos) {
        return s.substr(0, idx) + replacement + s.substr(idx + to_replace.length());
    }
    return s;
}

// todo quoting errors with Timeline Explorer
void print_value(json ev, std::string key) {
    if (ev[key].is_string()) {
        std::string s = ev[key].get<std::string>();
        s = translate_if_path(s);
        std::cout << "\"" << s << "\"";
    }
    else {
        std::cout << ev[key].dump();
    }
}


// output all events as a sparse CSV timeline with merged PPID and FilePath
void output_timeline_csv(const std::vector<json>& events) {
    // keys to merge for PPID and FilePath
    // TODO: write to config
    static const std::vector<std::string> ppid_keys = {
        "PPID",  "Parent PID", "TPID", "Target PID", "TargetPID" // TargetPID? 
        //(T)TID -> (target) thread ID, irrelevant now
    };
    static const std::vector<std::string> filepath_keys = {
        "FileName", "File Name", "File Path", "Image Path", "Process Image Path", "Name", "Reason Image Path" // FileName, ImageName?
    };

    // start of CSV header
    // TODO: Timeline Explorer: "name" not allowed?
    std::vector<std::string> all_keys = { TIMESTAMP, TYPE, PROVIDER_NAME, EVENT_ID, TASK, PID,
		"PPID", "Message", "Command Line", "FilePath", "VName", "Sig Seq", "Sig Sha" };

    // collect all property keys except merged ones, set automatically rejects duplicates
    for (const auto& ev : events) {
        for (auto it = ev.begin(); it != ev.end(); ++it) {
            // skip merged keys
            if (std::find(ppid_keys.begin(), ppid_keys.end(), it.key()) != ppid_keys.end()) continue;
            if (std::find(filepath_keys.begin(), filepath_keys.end(), it.key()) != filepath_keys.end()) continue;

            // skip already inserted keys
            if (std::find(all_keys.begin(), all_keys.end(), it.key()) != all_keys.end()) continue;

            // insert if it does not exists yet
            all_keys.push_back(it.key());
        }
    }

    // print CSV header
    for (const auto& key : all_keys) {
        std::cout << key << ",";
    }
    std::cout << "\n";

    // print each event as a row
    for (const auto& ev : events) {
        // traverse keys in order of csv header, print "" if the current event does not have this key
        for (const auto& key : all_keys) {
			// example: PPID (this is a merged key, there are no other keys like Parent PID, ... in the header)

            // check if the key is a merged key
            if (std::find(ppid_keys.begin(), ppid_keys.end(), key) != ppid_keys.end()) {
                for (auto& it: ev.items()) { // get the original key from the EVENT, not CSV HEADER
                    if (std::find(ppid_keys.begin(), ppid_keys.end(), it.key()) != ppid_keys.end()) {
                        print_value(ev, it.key());
                        break;
                    }
				}
            }
            else if (std::find(filepath_keys.begin(), filepath_keys.end(), key) != filepath_keys.end()) {
                for (auto& it : ev.items()) { // get the original key from the EVENT, not CSV HEADER
                    if (std::find(filepath_keys.begin(), filepath_keys.end(), it.key()) != filepath_keys.end()) {
                        print_value(ev, it.key());
                        break;
                    }
                }
            }

            // else check if this event has a value for this key
             else if (ev.contains(key)) {
                print_value(ev, key);
            }

            // else print "" to skip it
            else {
                std::cout << "";
            }
            std::cout << ",";
        }
        std::cout << "\n";
    }
}

// https://stackoverflow.com/questions/14265581/parse-split-a-string-in-c-using-string-delimiter-standard-c#answer-46931770
std::vector<std::string> split(const std::string& s, char delim) {
    std::vector<std::string> result;
    std::stringstream ss(s);
    std::string item;

    while (getline(ss, item, delim)) {
        result.push_back(item);
    }

    return result;
}

// TODO: actually parse csv?
std::vector<json> get_attack_events(std::string infile) {
    std::vector<json> attack_events;
    json j;

    std::string line;
    std::ifstream input(infile);

    // read the csv header first
    std::getline(input, line);
    std::string csv_header = line;

    // parse the rest
    while (std::getline(input, line)) {
        std::vector<std::string> data = split(line, ',');
        // TODO: less magic?
        j[TIMESTAMP] = data[0];
        j[TYPE] = data[1];
        j[PROVIDER_NAME] = data[2];
        j[EVENT_ID] = _strtoi64(data[3].c_str(), nullptr, 10);
        j[PID] = _strtoi64(data[5].c_str(), nullptr, 10);
        j[TASK] = data[5];
        attack_events.push_back(j);
    }

	std::cout << "[*] EDRi: Got " << attack_events.size() << " events from " << infile << "\n";
    return attack_events;
}

std::vector<json> merge_events(const std::vector<json> events, const std::vector<json> attack_events) {
    if (attack_events.size() != 0) {
        std::cout << "[*] EDRi: Merging " << attack_events.size() << " attack events into " << events.size() << " ETW events\n";
        std::vector<json> merged;
        // merge events from attack.csv
        int idx_event_to_merge = 0;
        json attack_event_to_merge = attack_events[idx_event_to_merge];
		bool all_merged = false;

        for (const auto& ev : events) {
            // iterate until we find an ETW event AFTER the attack event
			// then insert all attack events that happened cronologically before this event, locally before this event
            while (!all_merged && attack_event_to_merge[TIMESTAMP].get<std::string>() < ev[TIMESTAMP].get<std::string>()) {
                merged.push_back(attack_event_to_merge); // insert attack before this event
                idx_event_to_merge += 1;
                if (idx_event_to_merge == attack_events.size()) {
                    all_merged = true;
                    break; // all merged
                }
                attack_event_to_merge = attack_events[idx_event_to_merge];
            }
            merged.push_back(ev); // then insert the event (after the attack event(s))
        }
        // merge any attack_events that happened after the last event
        for (int i = idx_event_to_merge; i < attack_events.size(); i++) {
            merged.push_back(attack_events[i]);
        }

        std::cout << "[*] EDRi: Now " << merged.size() << " events\n";
        return merged;
    }
    std::cout << "[*] No attack events to merge\n";
    return events;
}

int get_PID_by_name(std::string exe_name) {
    PROCESSENTRY32 pe;
    pe.dwSize = sizeof(PROCESSENTRY32);
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (Process32First(snapshot, &pe)) {
        while (Process32Next(snapshot, &pe)) {
            if (wcscmp(pe.szExeFile, std::wstring(exe_name.begin(), exe_name.end()).c_str()) == 0) {
                return pe.th32ProcessID;
            }
        }
    }
    std::cerr << "[!] EDRi: Unable to find PID for: " << exe_name;
    exit(1);
}

int main(int argc, char* argv[]) {
    cxxopts::Options options("EDRi", "EDR Introspection Framework");

    options.add_options()
        ("e,exe", "EDR Executable Name", cxxopts::value<std::string>())
        ("a,attackOutput", "The Path of the attack-output.csv", cxxopts::value<std::string>())
        ("h,help", "Print usage");

    cxxopts::ParseResult result;
    try {
        result = options.parse(argc, argv);
    }
    catch (const cxxopts::exceptions::parsing& e) {
        std::cerr << "Error parsing options: " << e.what() << "\n";
        std::cout << options.help() << "\n";
        return 1;
	}
    std::cout << "[*] EDRi: EDR Introspection Framework\n";

    if (result.count("help") || result.count("e") == 0 || result.count("a") == 0) {
        std::cout << options.help() << "\n";
        return 0;
    }

    g_EDR_PID = get_PID_by_name(result["exe"].as<std::string>());
    std::cerr << "[+] EDRi: Got PID for " << result["exe"].as<std::string>() << ": " << g_EDR_PID << "\n";
    std::cout << "[*] EDRi: Start the attack when the 'Trace started' appears\n";

    std::vector<HANDLE> threads;
    if (!start_etw_reader(threads)) { // try to start trace
        exit(1);
    }
	// wait untiil g_trace_running is true
	while (!g_trace_running) {
		Sleep(10);
	}
	std::cout << "[*] EDRi: Trace started, ready for attack\n";
    std::cout << "[*] EDRi: Press ENTER after the attack is finished\n"; // todo invoke the attack here and observe?
    std::cin.get();

    std::vector<json> events = get_events();
    std::cout << "[*] EDRi: Stopping traces\n";
    stop_etw_reader();
    DWORD res = WaitForMultipleObjects((DWORD)threads.size(), threads.data(), TRUE, INFINITE);
    if (res == WAIT_FAILED) {
        std::cout << "[!] EDRi: Wait failed";
    }
    std::cout << "[*] EDRi: All " << threads.size() << " threads finished\n";

    std::vector<json> attack_events = get_attack_events(result["attackOutput"].as<std::string>());
    events = merge_events(events, attack_events);
    output_timeline_csv(events);
}