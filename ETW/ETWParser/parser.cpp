#include <iostream>
#include <fstream>
#include <map>
#include <regex>
#include <set>
#include <sstream>
#include <string>
#include <string.h>

#include <unordered_map>
#include <vector>
#include <windows.h>

#include "json.hpp"
#include "etwreader.h"
#include "globals.h"

/*
- creates krabs ETW traces for Antimalware, Kernel, etc.
- invokes the attack, and reads the output.csv generated by the attack.exe
- merges the output.csv events in between the captured events
- then transforms the captured events into a "filtered" csv, ready for Timeline Explorer
*/

// PID of the EDR process, used to filter the ETW Antimalware provider
int g_EDR_PID = 0;


// translate device paths to drive letters
std::string translate_if_path(const std::string& s) {
    std::string to_replace = "\\Device\\HarddiskVolume4\\";
    std::string replacement = "C:\\";
    size_t idx = s.find(to_replace);
    if (idx != std::string::npos) {
        return s.substr(0, idx) + replacement + s.substr(idx + to_replace.length());
    }
    return s;
}

// todo quoting errors with Timeline Explorer
void print_value(json ev, std::string key) {
    if (ev[key].is_string()) {
        std::string s = ev[key].get<std::string>();
        s = translate_if_path(s);
        std::cout << "\"" << s << "\"";
    }
    else {
        std::cout << ev[key].dump();
    }
}


// output all events as a sparse CSV timeline with merged PPID and FilePath
void output_timeline_csv(const std::vector<json>& events) {
    // keys to merge for PPID and FilePath
    static const std::vector<std::string> ppid_keys = {
        "Parent PID", "TPID", "Target PID"
    };
    static const std::vector<std::string> filepath_keys = {
        "File Name", "File Path", "Process Image Path", "Name", "Reason Image Path"
    };

    // start of CSV header
    // TODO: "name" not allowed?
    std::vector<std::string> all_keys = { TIMESTAMP, PROVIDER_NAME, EVENT_ID, TASK, PID,
		"PPID", "Message", "Command Line", "FilePath", "VName", "Sig Seq", "Sig Sha" };

    // collect all property keys except merged ones, set automatically rejects duplicates
    for (const auto& ev : events) {
        for (auto it = ev.begin(); it != ev.end(); ++it) {
            // skip merged keys
            if (std::find(ppid_keys.begin(), ppid_keys.end(), it.key()) != ppid_keys.end()) continue;
            if (std::find(filepath_keys.begin(), filepath_keys.end(), it.key()) != filepath_keys.end()) continue;

            // skip already inserted keys
            if (std::find(all_keys.begin(), all_keys.end(), it.key()) != all_keys.end()) continue;

            // insert if it does not exists yet
            all_keys.push_back(it.key());
        }
    }

    // print CSV header
    for (const auto& key : all_keys) {
        std::cout << key << ",";
    }
    std::cout << "\n";

    // print each event as a row
    for (const auto& ev : events) {
        // traverse keys in order of csv header, print "" if the current event does not have this key
        for (const auto& key : all_keys) {

            // check if this event has a value for this key
            if (ev.contains(key)) {
                print_value(ev, key);
            }
            // else check if the key is a merged key
            else if (std::find(ppid_keys.begin(), ppid_keys.end(), key) != ppid_keys.end()) {
                print_value(ev, key);
            }
            else if (std::find(filepath_keys.begin(), filepath_keys.end(), key) != filepath_keys.end()) {
                print_value(ev, key);
            }

            // else print "" to skip it
            else {
                std::cout << "";
            }
            std::cout << ",";
        }
        std::cout << "\n";
    }
}

// https://stackoverflow.com/questions/14265581/parse-split-a-string-in-c-using-string-delimiter-standard-c#answer-46931770
std::vector<std::string> split(const std::string& s, char delim) {
    std::vector<std::string> result;
    std::stringstream ss(s);
    std::string item;

    while (getline(ss, item, delim)) {
        result.push_back(item);
    }

    return result;
}

// TODO: actually parse csv?
std::vector<json> get_attack_events(std::string infile) {
    std::vector<json> attack_events;
    json j;

    std::string line;
    std::ifstream input(infile);

    // read the csv header first
    std::getline(input, line);
    std::string csv_header = line;

    // parse the rest
    while (std::getline(input, line)) {
        std::vector<std::string> data = split(line, ',');
        // TODO: less magic?
        j[TIMESTAMP] = data[0];
        j[PROVIDER_NAME] = data[1];
        j[EVENT_ID] = _strtoi64(data[2].c_str(), nullptr, 10);
        j[PID] = _strtoi64(data[3].c_str(), nullptr, 10);
        j[TASK] = data[4];
        attack_events.push_back(j);
    }

	std::cout << "[*] EDRi: Got " << attack_events.size() << " events from " << infile << "\n";
    return attack_events;
}

std::vector<json> merge_events(const std::vector<json> events, const std::vector<json> attack_events) {
    if (attack_events.size() != 0) {
        std::cout << "[*] EDRi: Merging " << attack_events.size() << " attack events into " << events.size() << " ETW events\n";
        std::vector<json> merged;
        // merge events from attack.csv
        int idx_event_to_merge = 0;
        json attack_event_to_merge = attack_events[idx_event_to_merge];
		bool all_merged = false;

        for (const auto& ev : events) {
            std::cout << "it: " << merged.size() << "\n";
            // iterate until we find an ETW event AFTER the attack event
			// then insert all attack events that happened cronologically before this event, locally before this event
            while (!all_merged && attack_event_to_merge[TIMESTAMP].get<std::string>() < ev[TIMESTAMP].get<std::string>()) {
                merged.push_back(attack_event_to_merge); // insert attack before this event
                idx_event_to_merge += 1;
                if (idx_event_to_merge == attack_events.size()) {
                    all_merged = true;
                    break; // all merged
                }
                attack_event_to_merge = attack_events[idx_event_to_merge];
            }
            merged.push_back(ev); // then insert the event (after the attack event(s))
        }
        // merge any attack_events that happened after the last event
        for (int i = idx_event_to_merge; i < attack_events.size(); i++) {
            merged.push_back(attack_events[i]);
        }

        std::cout << "[*] EDRi: Now " << merged.size() << " events\n";
        return merged;
    }
    std::cout << "[*] No attack events to merge\n";
    return events;
}

/*
int get_PID_by_name(std::string exe_name) {
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (Process32First(snapshot, &entry)) {
        while (Process32Next(snapshot, &entry)) {
            if (stricmp(entry.szExeFile, exe_name) == 0) {
                return entry.th32ProcessID;
            }
        }
    }
    std::cerr << "[!] Unable to find PID for: " << exe_name;
    exit(1);
}
*/

int main(int argc, char* argv[]) {
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " <PID to track> <attack-output.csv> \n";
        return 1;
    }
    std::cout << "[*] Start the attack when the 'Trace started' appears\n";

    //g_EDR_PID = get_PID_by_name(argv[1]);
	g_EDR_PID = strtol(argv[1], nullptr, 10);

    std::vector<HANDLE> threads;
    if (!start_etw_reader(threads)) { // try to start trace
        exit(1);
    }
	std::cout << "[*] Press ENTER after the attack is finished...\n"; // todo invoke the attack here and observe?
	std::cin.get();

    std::vector<json> events = get_events();
    std::cout << "[*] EDRi: Stopping traces\n";
    stop_etw_reader();
    /*
    DWORD res = WaitForMultipleObjects((DWORD)threads.size(), threads.data(), TRUE, INFINITE);
    if (res == WAIT_FAILED) {
        std::cout << "[!] EDRi: Wait failed";
    }
    std::cout << "[*] EDRi: All " << threads.size() << " threads finished\n";
    */
	Sleep(2000); // wait a bit to ensure all events are processed

    std::vector<json> attack_events = get_attack_events(argv[2]);
    events = merge_events(events, attack_events);
    output_timeline_csv(events);
}